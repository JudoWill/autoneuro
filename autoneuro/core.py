# AUTOGENERATED! DO NOT EDIT! File to edit: 00_core.ipynb (unless otherwise specified).

__all__ = ['LookupNormalTransform', 'FILTER_MAPPINGS']

# Cell
#export

import pandas as pd

from sklearn.base import BaseEstimator, TransformerMixin
from scipy.stats import norm

# Cell
#hide

FILTER_MAPPINGS = {'gt': '>',
                   'gte': '>=',
                   'lte': '<=',
                   'lt': '<',
                   'eq': '--',
                   'neq': '!='}



def _build_filters(lookup_table):
    """
    Build filters from lookup table
    Parameters
    ----------
    lookup_table : pd.DataFrame

    Returns
    -------

    """


    filts = dict((_id, []) for _id in lookup_table.index)
    expected = set()
    for col in lookup_table.columns:
        if '__' in col:
            field, nop = col.split('__')
            op = FILTER_MAPPINGS.get(nop, None)
            if op is not None:
                expected.add(field)
                for ind, val in lookup_table[col].to_dict().items():
                    if type(val) == str:
                        filts[ind].append(f'({field} {op} "{val}")')
                    else:
                        filts[ind].append(f'({field} {op} {val})')
    return pd.Series([' & '.join(filts[ind]) for ind in lookup_table.index],
                     index = lookup_table.index), sorted(expected)

def _build_lookup_norms(lookup_table):
    """

    Pulls out the values of the __mean and __std columns to create a
    pd.Series of scipy.norm instances.

    This can be better generalized in the future.

    Parameters
    ----------
    lookup_table : pd.DataFrame

    Returns
    -------
    ps.Series
    """

    mean_col = next(col for col in lookup_table.columns if col.endswith('__mean'))
    std_col = next(col for col in lookup_table.columns if col.endswith('__std'))

    field = mean_col.split('__')[0]

    return mean_col, std_col, field



    norm_list = []
    for _, row in lookup_table.iterrows():
        norm_list.append(norm(loc = row[mean_col],
                               scale = row[std_col]))
    return pd.Series(norm_list, index = lookup_table.index), fields




class LookupNormalTransform(BaseEstimator, TransformerMixin):

    def __init__(self, lookup_table=None, name = ''):
        """

        Parameters
        ----------
        lookup_table : pd.DataFrame
          Formatted lookup-table for the transformer
        """
        super(LookupNormalTransform, self).__init__()


        self.lookup_table = lookup_table
        self.name = name


    def fit(self, *args, **kwargs):
        self._filters, self._filter_cols = _build_filters(self.lookup_table)
        self._mean_col, self._std_col, self._measure_col = _build_lookup_norms(self.lookup_table)
        return self

    @property
    def needed_cols(self):
        return self._filter_cols + [self._measure_col]

    def get_feature_names(self):
        return [self.name]

    def match_samples(self, data, keep = 'last'):

        linker_func = lambda flt: data.query(flt).index
        all_matches = self._filters.map(linker_func)

        data2flt = {}
        for num, matches in all_matches.to_dict().items():
            for d_ind in matches:
                data2flt[d_ind] = num
        data2flt = pd.Series(data2flt)
        return data2flt.reindex(data.index)


    def normalize_samples(self, data, matched_rows = None):

        if matched_rows is None: matched_rows = self.match_samples(data)

        valid_matches = matched_rows.dropna()
        obs_vals = data.loc[valid_matches.index, self._measure_col]
        means = self.lookup_table.loc[valid_matches.values, self._mean_col]
        stds = self.lookup_table.loc[valid_matches.values, self._std_col]
        Zs = pd.Series((obs_vals.values-means.values)/stds.values,
                       valid_matches.index,
                       name = self.name)

        return Zs.reindex(data.index)


    def transform(self, data):

        return pd.DataFrame(self.normalize_samples(data))






