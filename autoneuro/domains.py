# AUTOGENERATED! DO NOT EDIT! File to edit: 03_domains.ipynb (unless otherwise specified).

__all__ = ['zscore2deficit', 'CNNSConversionOp', 'DomainScoreOp', 'DeficitScoreOp', 'ABDomainBattery', 'quantile_df',
           'AbstractDomain', 'quantile_df', 'quantile_transform_placeholders', 'VisuospatialMemoryBattery',
           'NewVisuospatialMemoryBattery', 'VisuospatialMemoryDomain', 'ProcessingSpeedBattery',
           'ProcessingSpeedDomain', 'MotorBattery', 'NewMotorBattery', 'MotorDomain', 'ExecutiveFunctionBattery',
           'NewExecutiveFunctionBattery', 'ExecutiveFunctionDomain', 'AttentionBattery', 'AttentionDomain',
           'LanguageBattery', 'NewLanguageBattery', 'LanguageDomain', 'VisuoSpatialBattery', 'NewVisuoSpatialBattery',
           'VisuoSpatialDomain', 'Collection']

# Cell
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sbn
import yaml

from .operators import AbstractOperation, AggregationOp
from .calculators import TestCalculator
from .field_mapping import *
from .batteries import *

# Cell
# hide
from bokeh.transform import factor_cmap, factor_mark
from bokeh.models import BooleanFilter, CDSView, BoxAnnotation, Band, IndexFilter, BooleanFilter, FactorRange
from bokeh.models import Legend, LegendItem

from bokeh.models import ColumnDataSource, HoverTool, Range1d
from bokeh.plotting import figure
from bokeh.layouts import gridplot, layout
from bokeh.io import show

# Cell
# hide

def zscore2deficit(zscore):

    # nan
    if (zscore != zscore) or (zscore is None):
        return np.nan
    tscore = (zscore*10)+50
    if tscore >= 40:
        return 0
    elif tscore >= 35:
        return 1
    elif tscore >= 30:
        return 2
    elif tscore >= 25:
        return 3
    elif tscore >= 20:
        return 4

    return 5


class CNNSConversionOp(AbstractOperation):

    def __init__(self, in_field, out_field = None):

        if out_field is None:
            out_field = in_field.rsplit('_', 1)[0]
            out_field += '_z'

        self.fields = [in_field]
        self.result_fields = [out_field]

        self.internal_field = out_field
        self.calculation = f'Z-score scaling of CNNS T-scale result of {in_field}'

    @staticmethod
    def multi_cnns(*args):

        return [CNNSConversionOp(field) for field in args]



    def explain(self, row):
        zscale = self.process_single(row)
        data = self.to_series(row)
        tscore = data[self.fields[0]]

        message = [f'CNNS Scaling: Scaling t-score {self.fields[0]} = {tscore}',
                   f'CNNS Scaling: to z-scale {self.result_fields[0]} = {zscale}'
                  ]

        return '\n'.join(message)

    def process_single(self, row):
        data = self.to_series(row)
        zscale = (data[self.fields[0]]-50)/10
        return zscale



class DomainScoreOp(AggregationOp):

    def __init__(self, out_field, fields, aggregation='mean'):
        """

        Parameters
        ----------
        out_field : str
        aggregation : str
        fields : list[str]
        """

        self.fields = fields
        self.aggregation = aggregation
        self.result_fields = [out_field]

        self.internal_field = out_field
        self.calculation = f'{aggregation} of {fields}'


class DeficitScoreOp(AbstractOperation):

    def __init__(self, in_field, out_field):

        self.fields = [in_field]
        self.result_fields = [out_field]

        self.internal_field = out_field
        self.calculation = f'Defict score scaling of {in_field}'

    def explain(self, row):
        deficit = self.process_single(row)
        zscore = row[self.fields[0]]
        tscore = (zscore*10)+50
        message = [f'Deficit Scaling: {self.fields[0]} = {row[self.fields[0]]} in z-scale units',
                   f'Deficit Scaling: Converted to a T-score of {tscore}',
                   f'Deficit Scaling: Which is a deficit score of {deficit}',
                  ]

        return '\n'.join(message)

    def process_single(self, row):
        data = self.to_series(row)
        deficit = zscore2deficit(data[self.fields[0]])
        return deficit




class ABDomainBattery(AbstractBattery):

    prefix = ''
    domain_cols = []
    prefix_ops = []


    @property
    def deficit_score_field(self):
        return self.prefix + '_deficit'

    @property
    def z_score_field(self):
        return self.prefix + '_z'


    @classmethod
    def from_defaults(cls, root_data = '/data'):

        dom_score = DomainScoreOp(cls.prefix + '_z',
                                  cls.domain_cols) # 'senas_wordlist_total'
        deficit_score = DeficitScoreOp(cls.prefix + '_z',
                                       cls.prefix + '_deficit')
        calc = TestCalculator(cls.prefix, cls.prefix_ops + [dom_score, deficit_score])

        return cls(calc, [cls.prefix + '_z'])





# Cell
# hide

import os
from itertools import chain
from sklearn.decomposition import TruncatedSVD
from sklearn.preprocessing import QuantileTransformer
from sklearn.impute import KNNImputer
from sklearn.preprocessing import quantile_transform

def quantile_df(df, **kwargs):

    normed = quantile_transform(df, **kwargs)
    return pd.DataFrame(normed, index = df.index, columns = df.columns)



class AbstractDomain(object):

    source = None
    data = None
    ranges = {}
    _weights = 1
    tools = "pan,wheel_zoom,box_zoom,reset,box_select,lasso_select"

    def __init__(self, batteries, deficit_score_name = None, final_fields = None):
        """
        Parameters
        ----------
        batteries : list[Battery]
        agg_method : str
        """

        self.calculator = TestCalculator(self.name, [])
        for bat in batteries:
            self.calculator = self.calculator + bat.calculator
        self.batteries = batteries
        if deficit_score_name is None:
            try:
                deficit_score_name = self.batteries[-1].deficit_score_field
            except AttributeError:
                pass
        self.deficit_score_name = deficit_score_name
        self.domain_score_field = batteries[-1].scaled_fields[0]
        self._final_fields = batteries[-1].domain_cols if final_fields is None else final_fields

    @property
    def name(self):
        return self.__class__.__name__


    @property
    def final_fields(self):
        if self._final_fields is None:
            fields = []
            for battery in self.batteries:
                fields += battery.scaled_fields
            return fields
        else:
            return self._final_fields

    @property
    def required_fields(self):
        fields = []
        for battery in self.batteries:
            fields += battery.required_fields
        return sorted(set(fields))


    def _load_data(self):
        pass

    def group_data(self, data):

        ages = pd.cut(data['age'], [18, 50, 100])
        return ages

    def __call__(self, df):

        res = self.calculator.process_dataframe(df)
        res = res.loc[:, ~res.columns.duplicated()]
        return res


    def scale_data(self, data):

        n_quantiles = 50
        scaled_data = []

        for battery in self.batteries:
            dt = battery.scaled_data(data)
            if battery.z_scaled:
                scaled_data.append(dt.copy())
            else:
                groups = self.group_data(data)
                out_data = dt.groupby(groups).apply(lambda x: quantile_df(x, output_distribution = 'normal', n_quantiles=n_quantiles))
                scaled_data.append(out_data.copy())

        return pd.concat(scaled_data, axis=1)


    def load_data(self, data):

        scaled_data = self(data)
        self.data = scaled_data #pd.concat([data, scaled_data], axis=1)
        if 'age' not in self.data:
            self.data['age'] = data['age']
        self._load_data()
        #self.aggregate_scores()
        self.source = ColumnDataSource(self.data)



    def build_scatter_fig(self, x = None, y = None,
                          fig = None, scatter_kwargs = None):

        x_range = self.ranges.get(x, Range1d(-10, 10))
        y_range = self.ranges.get(y, Range1d(-10, 10))
        default = {'x_range': x_range, 'y_range': y_range, 'tools': self.tools}
        if fig is None:
            fig = figure(**default)
        elif type(fig) == dict:
            fig = figure(**fig, **default)

        scatter_kwargs = {} if scatter_kwargs is None else scatter_kwargs
        fig.scatter(x = x, y = y, source = self.source,
                    **scatter_kwargs)
        fig.xaxis.axis_label = x
        fig.yaxis.axis_label = y

        self.ranges[x] = fig.x_range
        self.ranges[y] = fig.y_range

        return fig

    def aggregate_scores(self):

        ndata = self.data[self.final_fields].dropna(axis=1, how = 'all')
        if len(ndata.columns) >= 2:
            filled_data = KNNImputer().fit_transform(ndata)
            svd = TruncatedSVD(n_components=1, random_state=12)
            svd.fit(filled_data)
            weights = np.abs(svd.components_[0, :]) # Deal with sign
            weights = weights / np.sum(weights) # Deal with scale
            self._weights = pd.Series(weights, index = ndata.columns)
        else:
            self._weights = pd.Series([1]*len(ndata.columns), index = ndata.columns)

        if self.agg_method == 'SVD':
            def linker(row, weights):
                mask = row.notnull()
                if mask.any():
                    return np.average(row[mask], weights = weights[mask])
                return np.nan

            res = ndata.apply(lambda row: linker(row, weights), axis=1)

        elif self.agg_method == 'mean':
            res = ndata.clip(lower=-3, upper=3).mean(axis=1)
        else:
            raise ValueError('Did not understand aggmethod: ' + self.agg_method)

        self.data['aggregated_score'] = res
        self.data['deficit_score'] = self.data['aggregated_score'].map(zscore2defict)

    def build_aggscore_figures(self, fig = None, scatter_kwargs = None):

        if 'aggregated_score' not in self.data.columns:
            self.aggregate_scores()

        figs = []
        for col in self.data.columns:
            figs.append(self.build_scatter_fig(x = col, y = 'aggregated_score',
                                               scatter_kwargs=scatter_kwargs,
                                               fig=fig))

        return figs

    @property
    def corr_mat(self):
        plt_data = self.data[self.final_fields+['age']]
        return plt_data.loc[:, ~plt_data.columns.duplicated()].corr()

    def build_pairplot(self, extra_cols = ['age'], pairplot_kwargs = {}):
        plt_data = self.data[self.final_fields+extra_cols]
        return sbn.pairplot(plt_data.loc[:, ~plt_data.columns.duplicated()], **pairplot_kwargs)

    def build_deficit_plot(self, field = None, ax = None):
        field = self.deficit_score_name if field is None else field
        sbn.countplot(data = self.data,
                      x = field,
                      ax = ax)
        return ax

    def summarize_domain(self, data):
        self.load_data(data)

        print(self.name)
        print('Batteries: ' + ', '.join(bat.__class__.__name__ for bat in self.batteries))
        print('Composed of: ' + ', '.join(self.final_fields))

        print('Example calculation:')
        item = data.sample(1)
        print(self.calculator.explain(item.iloc[0]))


        self.build_pairplot()
        fig, ax = plt.subplots(1,1)
        self.build_deficit_plot(ax=ax)

        return self



# Cell
# hide
from sklearn.preprocessing import quantile_transform

def quantile_df(df, **kwargs):

    normed = quantile_transform(df, **kwargs)
    return pd.DataFrame(normed, index = df.index, columns = df.columns)


def quantile_transform_placeholders(data, suffix = '_plc', n_quantiles = 50, age_norm = True):

    cols = [col for col in data.columns if col.endswith(suffix)]

    if age_norm:
        ages = pd.cut(data['age'], [18, 50, 100])
        out_data = data.groupby(ages)[cols].apply(lambda x: quantile_df(x, output_distribution = 'normal', n_quantiles=n_quantiles))
    else:
        out_data = quantile_df(data[cols], output_distribution = 'normal', n_quantiles=n_quantiles)

    return pd.DataFrame(out_data, columns = cols, index = data.index)


#quantile_transform_placeholders(ex_fun_domain.data, suffix='unnorm').plot(kind = 'hist')



# Cell

from .batteries import BVMTBattery, HVLTBattery, SENASWordlistBattery, AbstractBattery

class VisuospatialMemoryBattery(ABDomainBattery):

    section = 'VisuospatialMemory Domain'
    prefix = 'vismemory_domain'
    domain_cols = ['bvmt_immediate_heaton',
                   'hvlt_recognition_heaton', 'hvlt_delay_heaton',
                   'hvlt_total_heaton']

class NewVisuospatialMemoryBattery(VisuospatialMemoryBattery):


    prefix_ops = CNNSConversionOp.multi_cnns('cnns_bvmt_t',
                                             'cnns_bvmt4_t',
                                             'cnns_bdiscrim_t',
                                             'cnns_bretain_t')
    domain_cols = ['cnns_bvmt_z',
                   'cnns_bvmt4_z',
                   'cnns_bdiscrim_z',
                  ]


class VisuospatialMemoryDomain(AbstractDomain):

    @staticmethod
    def from_defaults(root_data = 'data/', method = 'new'):

        batteries = [BVMTBattery.from_defaults()]
        if method == 'new':
            batteries.append(NewVisuospatialMemoryBattery.from_defaults())
        else:
            batteries.append(VisuospatialMemoryBattery.from_defaults())


        return VisuospatialMemoryDomain(batteries)

# Cell

from .batteries import GroovedPegBoardBattery, TrailABattery, \
StroopBattery, WAIS4DigitSymbolBattery

class ProcessingSpeedBattery(ABDomainBattery):

    section = 'ProcessingSpeed Domain'
    prefix = 'processing_domain'
    domain_cols = ['traila_heaton_z',
                   'stroopword_norman_z',
                   'stroopcolor_norman_z']

class ProcessingSpeedDomain(AbstractDomain):

    @staticmethod
    def from_defaults(root_data = 'data/', method = 'new'):

        batteries = [TrailABattery.from_defaults(),

                     StroopBattery.from_defaults(final_cols = ['stroopword_norman_z', 'stroopcolor_norman_z']),
                     ProcessingSpeedBattery.from_defaults()
                    ]

        return ProcessingSpeedDomain(batteries)

# Cell

from .batteries import GroovedPegBoardBattery, TrailABattery, \
StroopBattery, WAIS4DigitSymbolBattery

class MotorBattery(ABDomainBattery):

    section = 'Motor Domain'
    prefix = 'motor_domain'
    domain_cols = ['groovedpegdom_heaton_z', 'groovedpegnondom_heaton_z']


class NewMotorBattery(MotorBattery):

    prefix_ops = CNNSConversionOp.multi_cnns('cnns_gpdom1_t',
                                             'cnns_gpndom1_t',
                                             'cnns_gp_t1_mean_t')
    domain_cols = ['cnns_gpdom1_z',
                   'cnns_gpndom1_z']



class MotorDomain(AbstractDomain):

    @staticmethod
    def from_defaults(root_data = 'data/', method = 'new'):

        batteries = [GroovedPegBoardBattery.from_defaults()]

        if method == 'new':
            batteries.append(NewMotorBattery.from_defaults())
        else:
            batteries.append(MotorBattery.from_defaults())


        return MotorDomain(batteries)

# Cell

from .batteries import TrailBBattery, mWCSTBattery


class ExecutiveFunctionBattery(ABDomainBattery):

    section = 'ExecutiveFunction Domain'
    prefix = 'exec_domain'
    domain_cols = ['trailb_heaton_z',
                   'stroopcolorword_norman_z',
                  ]


class NewExecutiveFunctionBattery(ExecutiveFunctionBattery):

    prefix_ops = CNNSConversionOp.multi_cnns('cnns_trlsb_t',
                                             'cnns_wcscat_t',
                                             'cnns_wcsper_t',
                                             'cnns_wcserr_t')
    domain_cols = ['trailb_heaton_z',
                   'cnns_wcserr_z',
                   'stroopcolorword_norman_z']



class ExecutiveFunctionDomain(AbstractDomain):

    @staticmethod
    def from_defaults(root_data = 'data/', method = 'new'):

        batteries = [TrailBBattery.from_defaults(),
                     StroopBattery.from_defaults(final_cols = ['stroopcolorword_norman']),
                     mWCSTBattery.from_defaults(),
                    ]

        if method == 'new':
            batteries.append(NewExecutiveFunctionBattery.from_defaults())
        else:
            batteries.append(ExecutiveFunctionBattery.from_defaults())

        return ExecutiveFunctionDomain(batteries)

# Cell

class AttentionBattery(ABDomainBattery):

    section = 'Attention Domain'
    prefix = 'attention_domain'

    domain_cols = ['digitsforward_wais4_z',
                   'digitsbackward_wais4_z',
                   'digitssequencing_wais4_z']


class AttentionDomain(AbstractDomain):

    @staticmethod
    def from_defaults(root_data = 'data/', method = 'new'):
        batteries = [WAIS4DigitSymbolBattery.from_defaults(),
                     AttentionBattery.from_defaults()
                    ]


        return AttentionDomain(batteries)


# Cell

from .batteries import CategoryFluencyAnimalsBattery, LetterFluencyBattery


class LanguageBattery(ABDomainBattery):

    section = 'Language Domain'
    prefix = 'language_domain'
    domain_cols = ['letterfluencyfas_total_heaton_z',
                   'categoryfluency_total_heaton_z'
                  ]

class NewLanguageBattery(LanguageBattery):

    prefix_ops = CNNSConversionOp.multi_cnns('cnns_swords_t',
                                             'cnns_anwords_t',
                                             'cnns_bnt30_t')
    domain_cols = ['letterfluencyfas_total_heaton_z',
                   'categoryfluency_total_heaton_z',
                   'cnns_bnt30_z']


class LanguageDomain(AbstractDomain):


    @staticmethod
    def from_defaults(root_data = 'data/', method = 'new'):

        batteries = [LetterFluencyBattery.from_defaults(),
                     CategoryFluencyAnimalsBattery.from_defaults(),
                     BNT30Battery.from_defaults()]

        if method == 'new':
            batteries.append(NewLanguageBattery.from_defaults())
        else:
            batteries.append(LanguageBattery.from_defaults())


        return LanguageDomain(batteries)

# Cell

from .batteries import ClockDrawingBattery, ROCFBattery

class VisuoSpatialBattery(ABDomainBattery):

    section = 'VisuoSpatial Domain'
    prefix = 'visuospatial_domain' # visoconstruction
    domain_cols = ['clocksum',
                   'rocf'
                  ]


class NewVisuoSpatialBattery(VisuoSpatialBattery):

    prefix_ops = CNNSConversionOp.multi_cnns('cnns_clock1_t',
                                             'cnns_clock2_t',
                                             'cnns_clocksum_t',
                                             'cnns_reyo_t',
                                             'cnns_reytime_t')
    domain_cols = ['cnns_clocksum_z',
                   'cnns_reyo_z',]





class VisuoSpatialDomain(AbstractDomain):

    @staticmethod
    def from_defaults(root_data = 'data/', method = 'new'):

        batteries = [ClockDrawingBattery.from_defaults(),
                     ROCFBattery.from_defaults()]

        if method == 'new':
            batteries.append(NewVisuoSpatialBattery.from_defaults())
        else:
            batteries.append(VisuoSpatialBattery.from_defaults())

        return VisuoSpatialDomain(batteries)

# Cell
# hide

from .batteries import DemographicsBattery


class Collection(object):

    def __init__(self, mapper, domains, extra_batteries = None):

        self.mapper = mapper
        self.domains = dict((d.name, d) for d in domains)
        self.measured_data = None
        self.extra_batteries = extra_batteries if extra_batteries is not None else []
        self.extra_data = None

    @staticmethod
    def from_defaults(mapping_path = 'data/field_mappings_merged.xlsx', extra_post_convert = [], method = 'new'):

        mapper = FieldMapper.from_file('data/field_mappings_merged.xlsx',
                                      post_convert = [fix_dates, fix_study_ids]+extra_post_convert)
        domains = [VerbalMemoryDomain.from_defaults(method = method),
                   VisuospatialMemoryDomain.from_defaults(method = method),
                   ProcessingSpeedDomain.from_defaults(method = method),
                   MotorDomain.from_defaults(method = method),
                   ExecutiveFunctionDomain.from_defaults(method = method),
                   AttentionDomain.from_defaults(method = method),
                   LanguageDomain.from_defaults(method = method)]

        extra_batteries = [DemographicsBattery.from_defaults()]

        return Collection(mapper, domains, extra_batteries=extra_batteries)

    @property
    def domain_z_scores(self):

        fields = []
        for _, domain in self.domains.items():
            fields.append(domain.domain_score_field)
        return self.scaled_data[fields]

    @property
    def domain_deficit_scores(self):
        fields = []
        for _, domain in self.domains.items():
            fields.append(domain.deficit_score_name)
        return self.scaled_data[fields]


    def load_data(self, datasets, index_keys = ['study_id', 'date_of_visit']):
        """Load and merge multiple sources.
        Expects ('id_system', path) list as input.
        """

        self.measured_data = self.mapper.multi_merge('internal_field', datasets, index_keys = index_keys)
        return self


    def _scale_data(self, measured_data, as_multi_index = False,
                    extra_batteries = []):

        out = {}
        for key, domain in self.domains.items():
            out[key] = domain(measured_data)

        for bat in self.extra_batteries+extra_batteries:
            out[bat.__class__.__name__] = bat(measured_data)

        if as_multi_index:
            return pd.concat(out.values(),
                             axis=1,
                             keys=out.keys(),
                             sort=False)
        else:
            mat = pd.concat(out.values(),
                            axis=1,
                            sort=False)
            mat = mat.loc[:, ~mat.columns.duplicated()]
            return mat


    def scale_data(self, extra_batteries = []):

        self.scaled_data = self._scale_data(self.measured_data,
                                            as_multi_index=False,
                                           extra_batteries = extra_batteries)

        return self

    def to(self, path, id_system):


        if path.endswith('.xls') or path.endswith('.xlsx'):
            pass





