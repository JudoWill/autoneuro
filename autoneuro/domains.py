# AUTOGENERATED! DO NOT EDIT! File to edit: 03_domains.ipynb (unless otherwise specified).

__all__ = ['quantile_df', 'AbstractDomain', 'quantile_df', 'quantile_transform_placeholders', 'MemoryDomain',
           'MotorDomain', 'ExecutiveFunctionDomain', 'AttentionDomain', 'LanguageDomain', 'VisuoSpatialDomain']

# Cell
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sbn
import yaml


from .calculators import TestCalculator
from .field_mapping import FieldMapper

# Cell
# hide
from bokeh.transform import factor_cmap, factor_mark
from bokeh.models import BooleanFilter, CDSView, BoxAnnotation, Band, IndexFilter, BooleanFilter, FactorRange
from bokeh.models import Legend, LegendItem

from bokeh.models import ColumnDataSource, HoverTool, Range1d
from bokeh.plotting import figure
from bokeh.layouts import gridplot, layout
from bokeh.io import show

# Cell
# hide

import os
from itertools import chain
from sklearn.decomposition import TruncatedSVD
from sklearn.preprocessing import QuantileTransformer
from sklearn.impute import KNNImputer
from sklearn.preprocessing import quantile_transform

def quantile_df(df, **kwargs):

    normed = quantile_transform(df, **kwargs)
    return pd.DataFrame(normed, index = df.index, columns = df.columns)


class AbstractDomain(object):

    source = None
    data = None
    ranges = {}
    _weights = 1
    tools = "pan,wheel_zoom,box_zoom,reset,box_select,lasso_select"

    def __init__(self, batteries, agg_method = 'mean'):
        """

        Parameters
        ----------
        batteries : list[Battery]
        agg_method : str
        """

        self.batteries = batteries
        self.agg_method = agg_method

    @property
    def final_fields(self):
        fields = []
        for battery in self.batteries:
            fields += battery.scaled_fields
        return fields

    def _load_data(self):
        pass

    def group_data(self, data):

        ages = pd.cut(data['age'], [18, 50, 100])
        return ages

    def load_data(self, data, mapping=None):

        n_quantiles = 50
        scaled_data = []

        for battery in self.batteries:
            dt = battery.scaled_data(data)
            if battery.z_scaled:
                scaled_data.append(dt.copy())
            else:
                groups = self.group_data(data)
                out_data = dt.groupby(groups).apply(lambda x: quantile_df(x, output_distribution = 'normal', n_quantiles=n_quantiles))
                scaled_data.append(out_data.copy())

        self.data = pd.concat([data]+scaled_data, axis=1)
        self._load_data()
        self.aggregate_scores()
        self.source = ColumnDataSource(self.data)



    def build_scatter_fig(self, x = None, y = None,
                          fig = None, scatter_kwargs = None):

        x_range = self.ranges.get(x, Range1d(-10, 10))
        y_range = self.ranges.get(y, Range1d(-10, 10))
        default = {'x_range': x_range, 'y_range': y_range, 'tools': self.tools}
        if fig is None:
            fig = figure(**default)
        elif type(fig) == dict:
            fig = figure(**fig, **default)

        scatter_kwargs = {} if scatter_kwargs is None else scatter_kwargs
        fig.scatter(x = x, y = y, source = self.source,
                    **scatter_kwargs)
        fig.xaxis.axis_label = x
        fig.yaxis.axis_label = y

        self.ranges[x] = fig.x_range
        self.ranges[y] = fig.y_range

        return fig


    def aggregate_scores(self):

        ndata = self.data[self.final_fields]
        filled_data = KNNImputer().fit_transform(ndata)
        svd = TruncatedSVD(n_components=1, random_state=12)
        svd.fit(filled_data)
        weights = np.abs(svd.components_[0, :]) # Deal with sign
        weights = weights / np.sum(weights) # Deal with scale
        self._weights = pd.Series(weights, index = self.final_fields)

        if self.agg_method == 'SVD':
            def linker(row, weights):
                mask = row.notnull()
                if mask.any():
                    return np.average(row[mask], weights = weights[mask])
                return np.nan

            res = ndata.apply(lambda row: linker(row, weights), axis=1)

        elif self.agg_method == 'mean':
            res = ndata.clip(lower=-3, upper=3).mean(axis=1)
        else:
            raise ValueError('Did not understand aggmethod: ' + self.agg_method)

        self.data['aggregated_score'] = res
        self.data['deficit_score'] = (-res).clip(lower = 0)

    def build_aggscore_figures(self, fig = None, scatter_kwargs = None):

        if 'aggregated_score' not in self.data.columns:
            self.aggregate_scores()

        figs = []
        for col in self.data.columns:
            figs.append(self.build_scatter_fig(x = col, y = 'aggregated_score',
                                               scatter_kwargs=scatter_kwargs,
                                               fig=fig))

        return figs


    def build_piechart(self, ax=None):

        if ax is None:
            fig, ax = plt.subplots(1,1)

        ax.pie(self._weights,
               labels = self._weights.index,
               wedgeprops=dict(width=0.5, edgecolor='w'))

        return ax

    @property
    def corr_mat(self):
        return self.data[['age', 'aggregated_score'] + self.final_fields].corr()

    def build_pairplot(self, extra_cols = ['age', 'aggregated_score'], pairplot_kwargs = {}):
        return sbn.pairplot(self.data[self.final_fields+extra_cols], **pairplot_kwargs)

    def build_deficit_plot(self, ax = None):

        ax = self.data['deficit_score'].plot(kind = 'hist', bins = np.arange(0, 4, 0.25), ax=ax)
        return ax


    def summarize_domain(self, data):
        self.load_data(data)
        self.build_pairplot()

        self.build_piechart()

        self.build_deficit_plot()

        return self



# Cell
# hide
from sklearn.preprocessing import quantile_transform

def quantile_df(df, **kwargs):

    normed = quantile_transform(df, **kwargs)
    return pd.DataFrame(normed, index = df.index, columns = df.columns)


def quantile_transform_placeholders(data, suffix = '_plc', n_quantiles = 50, age_norm = True):

    cols = [col for col in data.columns if col.endswith(suffix)]

    if age_norm:
        ages = pd.cut(data['age'], [18, 50, 100])
        out_data = data.groupby(ages)[cols].apply(lambda x: quantile_df(x, output_distribution = 'normal', n_quantiles=n_quantiles))
    else:
        out_data = quantile_df(data[cols], output_distribution = 'normal', n_quantiles=n_quantiles)

    return pd.DataFrame(out_data, columns = cols, index = data.index)


#quantile_transform_placeholders(ex_fun_domain.data, suffix='unnorm').plot(kind = 'hist')



# Cell

from .batteries import BVMTBattery, HVLTBattery, SENASWordlistBattery

class MemoryDomain(AbstractDomain):

    @staticmethod
    def from_defaults(root_data = 'data/'):

        batteries = [BVMTBattery.from_defaults(),
                     HVLTBattery.from_defaults(),
                     SENASWordlistBattery.from_defaults()]


        return MemoryDomain(batteries)

# Cell

from .batteries import GroovedPegBoardBattery, TrailABattery, \
StroopBattery, WAIS4DigitSymbolBattery

class MotorDomain(AbstractDomain):

    @staticmethod
    def from_defaults(root_data = 'data/'):

        batteries = [GroovedPegBoardBattery.from_defaults(),
                     TrailABattery.from_defaults(),
                     WAIS4DigitSymbolBattery.from_defaults(),
                     StroopBattery.from_defaults(final_cols = ['stroopword_norman', 'stroopcolor_norman'])
                    ]


        return MotorDomain(batteries)

# Cell

from .batteries import TrailBBattery, mWCSTBattery

class ExecutiveFunctionDomain(AbstractDomain):

    @staticmethod
    def from_defaults(root_data = 'data/'):

        batteries = [TrailBBattery.from_defaults(),
                     StroopBattery.from_defaults(final_cols = ['stroopcolorword_norman']),
                     mWCSTBattery.from_defaults()
                    ]


        return ExecutiveFunctionDomain(batteries)

# Cell

class AttentionDomain(AbstractDomain):


    @staticmethod
    def from_defaults(root_data = 'data/'):
        wais_cols = ['digitsforwardwais4_plc', 'digitsbackwardwais4_plc', 'digitssequencingwais4_plc']
        batteries = [WAIS4DigitSymbolBattery.from_defaults(final_cols = wais_cols),
                    ]


        return AttentionDomain(batteries)


# Cell

from .batteries import CategoryFluencyAnimalsBattery, LetterFluencyBattery

class LanguageDomain(AbstractDomain):


    @staticmethod
    def from_defaults(root_data = 'data/'):

        batteries = [LetterFluencyBattery.from_defaults(),
                    CategoryFluencyAnimalsBattery.from_defaults()]


        return LanguageDomain(batteries)

# Cell

from .batteries import ClockDrawingBattery, ROCFBattery

class VisuoSpatialDomain(AbstractDomain):

    @staticmethod
    def from_defaults(root_data = 'data/'):

        batteries = [ClockDrawingBattery.from_defaults(),
                     ROCFBattery.from_defaults()]


        return VisuoSpatialDomain(batteries)