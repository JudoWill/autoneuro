---

title: Operators


keywords: fastai
sidebar: home_sidebar



nb_path: "01_operators.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: 01_operators.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Again, we'll uss the BVMT test as the example.
But we're going to back up a step. Since there are a bunch of different intermediate values, I want to calculate those using operations.</p>
<p>Measured Values:</p>
<ul>
<li><code>trial1</code> - Trial 1 successes</li>
<li><code>trial2</code> - Trial 2 successes</li>
<li><code>trial3</code> - Trial 3 successes</li>
<li><code>delay</code> - Delayed Successes</li>
<li><code>hits</code> - Successful recognitions with distractors</li>
<li><code>false_pos</code> - False-positive recognitions</li>
</ul>
<p>Our goal is to define all of the operations required to calculated intermediate values (ie immediate)
as well as scaled values.</p>
<p>There are three derived values to calculate:</p>
<ul>
<li><code>immediate</code>: the sum of the three trials</li>
<li><code>regonition</code>: the number of hits - false-positive recognitions</li>
<li><code>retention</code>: ratio of delayed successes and largest of the trial 2 &amp; trial 3 successes</li>
</ul>
<p>The first two can be solved with basic equations.
The third will require an additional strategy effort.</p>
<h2 id="Basic-Equations">Basic Equations<a class="anchor-link" href="#Basic-Equations"> </a></h2>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="EquationOp" class="doc_header"><code>class</code> <code>EquationOp</code><a href="https://github.com/judowill/autoneuro/tree/main/autoneuro/operators.py#L54" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>EquationOp</code>(<strong><code>out_field</code></strong>, <strong><code>equation</code></strong>, <strong><code>fields</code></strong>) :: <a href="/autoneuro/operators.html#AbstractOperation"><code>AbstractOperation</code></a></p>
</blockquote>
<p>Manipulate values with 1numexpr1 equations.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Let's imagine a individual to test.</p>
<p>Measured Values:</p>
<ul>
<li><code>trial1</code> - 5</li>
<li><code>trial2</code> - 6</li>
<li><code>trial3</code> - 7</li>
<li><code>delay</code> - 8</li>
<li><code>hits</code> - 6</li>
<li><code>false_pos</code> - 2</li>
<li><code>copy</code> - 12</li>
</ul>
<p>Using the <a href="/autoneuro/operators.html#EquationOp"><code>EquationOp</code></a> let's calculate <code>immediate</code> and <code>recognition</code>.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">DATA</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;trial1&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;trial2&#39;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="s1">&#39;trial3&#39;</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span>
        <span class="s1">&#39;delay&#39;</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="s1">&#39;hits&#39;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="s1">&#39;false_pos&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
        <span class="s1">&#39;copy&#39;</span><span class="p">:</span> <span class="mi">12</span><span class="p">}</span>

<span class="n">total_op</span> <span class="o">=</span> <span class="n">EquationOp</span><span class="p">(</span><span class="s1">&#39;immediate&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;trial1+trial2+trial3&#39;</span><span class="p">,</span>
                      <span class="p">[</span><span class="s1">&#39;trial1&#39;</span><span class="p">,</span> <span class="s1">&#39;trial2&#39;</span><span class="p">,</span> <span class="s1">&#39;trial3&#39;</span><span class="p">])</span>
<span class="n">immed</span> <span class="o">=</span> <span class="n">total_op</span><span class="o">.</span><span class="n">process_single</span><span class="p">(</span><span class="n">DATA</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">immed</span> <span class="o">==</span> <span class="mi">18</span>
<span class="n">DATA</span><span class="p">[</span><span class="s1">&#39;immediate&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">immed</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We can also <code>explain</code> the result using the method.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">total_op</span><span class="o">.</span><span class="n">explain</span><span class="p">(</span><span class="n">DATA</span><span class="p">))</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Used Equation: trial1+trial2+trial3 = 18 = immediate
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>While one might construct these operations in Python code, I actually expect most things to be saved as yaml.
So, we need a way to represent this info in that format.
This is also useful when constructing larger sets.</p>
<p>Here's the yaml example for the recognition calculation.</p>

<pre><code>type: equation
equation: "hits-false_pos"
fields: ['hits', 'false_pos']
out_field: 'recognition'</code></pre>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">yaml</span>

<span class="n">st</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">type: equation</span>
<span class="s2">equation: &quot;hits-false_pos&quot;</span>
<span class="s2">fields: [&#39;hits&#39;, &#39;false_pos&#39;]</span>
<span class="s2">out_field: &#39;recognition&#39;</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">ret_op</span> <span class="o">=</span> <span class="n">EquationOp</span><span class="o">.</span><span class="n">from_config</span><span class="p">(</span><span class="n">yaml</span><span class="o">.</span><span class="n">full_load</span><span class="p">(</span><span class="n">st</span><span class="p">))</span>
<span class="n">recog</span> <span class="o">=</span> <span class="n">ret_op</span><span class="o">.</span><span class="n">process_single</span><span class="p">(</span><span class="n">DATA</span><span class="p">)</span>

<span class="k">assert</span> <span class="n">recog</span> <span class="o">==</span> <span class="mi">4</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ret_op</span><span class="o">.</span><span class="n">explain</span><span class="p">(</span><span class="n">DATA</span><span class="p">))</span>
<span class="n">DATA</span><span class="p">[</span><span class="s1">&#39;recognition&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">recog</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Used Equation: hits-false_pos = 4 = recognition
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Aggregation-Operations">Aggregation Operations<a class="anchor-link" href="#Aggregation-Operations"> </a></h2><p>Due to limitations in numexpr, it cannot choose the largest of two numbers, as needed for retention.
So, we use an <a href="/autoneuro/operators.html#AggregationOp"><code>AggregationOp</code></a>.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="AggregationOp" class="doc_header"><code>class</code> <code>AggregationOp</code><a href="https://github.com/judowill/autoneuro/tree/main/autoneuro/operators.py#L133" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>AggregationOp</code>(<strong><code>out_field</code></strong>, <strong><code>aggregation</code></strong>, <strong><code>fields</code></strong>) :: <a href="/autoneuro/operators.html#AbstractOperation"><code>AbstractOperation</code></a></p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">ret_denom_op</span> <span class="o">=</span> <span class="n">AggregationOp</span><span class="p">(</span><span class="s1">&#39;retention_denom&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;trial2&#39;</span><span class="p">,</span> <span class="s1">&#39;trial3&#39;</span><span class="p">])</span>
<span class="n">re_denom</span> <span class="o">=</span> <span class="n">ret_denom_op</span><span class="o">.</span><span class="n">process_single</span><span class="p">(</span><span class="n">DATA</span><span class="p">)</span>

<span class="k">assert</span> <span class="n">re_denom</span> <span class="o">==</span> <span class="mi">7</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ret_denom_op</span><span class="o">.</span><span class="n">explain</span><span class="p">(</span><span class="n">DATA</span><span class="p">))</span>
<span class="n">DATA</span><span class="p">[</span><span class="s1">&#39;retention_denom&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">re_denom</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Aggregation: max [trial2, trial3]  = 7
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now that we have the denominator we can do another equation to calculate recognition.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">retent_op</span> <span class="o">=</span> <span class="n">EquationOp</span><span class="p">(</span><span class="s1">&#39;retention&#39;</span><span class="p">,</span> <span class="s1">&#39;delay/retention_denom&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;delay&#39;</span><span class="p">,</span> <span class="s1">&#39;retention_denom&#39;</span><span class="p">])</span>
<span class="n">retent</span> <span class="o">=</span> <span class="n">retent_op</span><span class="o">.</span><span class="n">process_single</span><span class="p">(</span><span class="n">DATA</span><span class="p">)</span>

<span class="k">assert</span> <span class="n">retent</span> <span class="o">==</span> <span class="mi">8</span><span class="o">/</span><span class="mi">7</span>
<span class="nb">print</span><span class="p">(</span><span class="n">retent_op</span><span class="o">.</span><span class="n">explain</span><span class="p">(</span><span class="n">DATA</span><span class="p">))</span>
<span class="n">DATA</span><span class="p">[</span><span class="s1">&#39;retention&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">retent</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Used Equation: delay/retention_denom = 1.1428571428571428 = retention
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Dang, the value was above 100%. And sometimes it may be negative.
By convention we clip these to a [0,1] scale, which we'll need an operation for that.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="ClipOp" class="doc_header"><code>class</code> <code>ClipOp</code><a href="https://github.com/judowill/autoneuro/tree/main/autoneuro/operators.py#L181" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>ClipOp</code>(<strong><code>field</code></strong>, <strong><code>lower</code></strong>=<em><code>0</code></em>, <strong><code>upper</code></strong>=<em><code>1</code></em>) :: <a href="/autoneuro/operators.html#AbstractOperation"><code>AbstractOperation</code></a></p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">ret_clip_op</span> <span class="o">=</span> <span class="n">ClipOp</span><span class="p">(</span><span class="s1">&#39;retention&#39;</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">upper</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">ret_clip</span> <span class="o">=</span> <span class="n">ret_clip_op</span><span class="o">.</span><span class="n">process_single</span><span class="p">(</span><span class="n">DATA</span><span class="p">)</span>

<span class="k">assert</span> <span class="n">ret_clip</span> <span class="o">==</span> <span class="mi">1</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ret_clip_op</span><span class="o">.</span><span class="n">explain</span><span class="p">(</span><span class="n">DATA</span><span class="p">))</span>
<span class="n">DATA</span><span class="p">[</span><span class="s1">&#39;retention&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ret_clip</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Clipped retention to [0, 1]
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now we've calculated all of the intermediate values.
We'll need to use these values, along with demographic data, to lookup a "healthy" normal distribution.</p>
<h2 id="Normative-Lookups">Normative Lookups<a class="anchor-link" href="#Normative-Lookups"> </a></h2><p>These lookup tables are composed of lookup tables that index a mean and std given a demographic filter.
For example:</p>
<p>A 32 year old should have an <code>immediate</code> memory of 26.9 with a std of 4.6.
Our example has an <code>immediate</code> of 18, a deficit of 9, roughly 2 stds.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="NormativeLookupOp" class="doc_header"><code>class</code> <code>NormativeLookupOp</code><a href="https://github.com/judowill/autoneuro/tree/main/autoneuro/operators.py#L232" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>NormativeLookupOp</code>(<strong><code>lookup_table</code></strong>, <strong><code>filter_cols</code></strong>, <strong><code>measure_col</code></strong>, <strong><code>out_name</code></strong>) :: <a href="/autoneuro/operators.html#AbstractOperation"><code>AbstractOperation</code></a></p>
</blockquote>
<p>Lookup table with normalized scores.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>While it is possible to create these in Python, it's much easier to build using yaml definitions.</p>

<pre><code>type: normative_lookup
measure_col: immediate
filter_cols: ['age']
out_name: 'heaton_immediate'
table:
  - filter: (18 &lt;= age) &amp; (age &lt;= 21)
    mean: 28.74
    std: 4.32
  - filter: (20 &lt;= age) &amp; (age &lt;= 23)
    mean: 28.44
    std: 4.38
  ...</code></pre>
<p>The filters are anything acceptable to <code>pd.eval</code>.
The Heaton norms for the BVMT are currently in <code>data/norms/from_kate/heaton_bvmt.yaml</code></p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">DATA</span><span class="p">[</span><span class="s1">&#39;age&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">32</span>
<span class="n">bvmt_config</span> <span class="o">=</span> <span class="n">yaml</span><span class="o">.</span><span class="n">full_load</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s1">&#39;data/norms/from_kate/heaton_bvmt.yaml&#39;</span><span class="p">))</span>

<span class="n">lookup_op</span> <span class="o">=</span> <span class="n">NormativeLookupOp</span><span class="o">.</span><span class="n">from_config</span><span class="p">(</span><span class="n">bvmt_config</span><span class="p">[</span><span class="s1">&#39;operations&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
<span class="n">lookup_score</span> <span class="o">=</span> <span class="n">lookup_op</span><span class="o">.</span><span class="n">process_single</span><span class="p">(</span><span class="n">DATA</span><span class="p">)</span>

<span class="k">assert</span> <span class="n">lookup_score</span> <span class="o">==</span> <span class="o">-</span><span class="mf">1.9224137931034488</span>
<span class="nb">print</span><span class="p">(</span><span class="n">lookup_op</span><span class="o">.</span><span class="n">explain</span><span class="p">(</span><span class="n">DATA</span><span class="p">))</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Matched (30 &lt;= age) &amp; (age &lt;= 33), Expecting 26.92 +- 4.64
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The collection of these operators can be combined into a <a href="/autoneuro/calculators.html#TestCalculator"><code>TestCalculator</code></a> which manages applying these operations sequentially.
That is discussed elsewhere.</p>
<p>These features are sufficient for any analysis that requires looking up normalizations based on demographic information.
However, for regression based norms like the <code>Norman</code> set we need a further collection of operators.</p>
<h2 id="Regression-Based-Norms">Regression Based Norms<a class="anchor-link" href="#Regression-Based-Norms"> </a></h2><p>When doing regression based normalization the first step is to <code>scale</code> the raw values based on a set of bins.
This is done to help <em>normalize</em> the raw values before entering the regression equation.</p>
<p>For example. When scaling the <code>delay</code> column, the <code>norman</code> scheme uses:</p>
<table>
<thead><tr>
<th>Raw</th>
<th>Scaled</th>
</tr>
</thead>
<tbody>
<tr>
<td>12</td>
<td>14</td>
</tr>
<tr>
<td>11</td>
<td>11</td>
</tr>
<tr>
<td>10</td>
<td>9</td>
</tr>
<tr>
<td>9</td>
<td>8</td>
</tr>
<tr>
<td>8</td>
<td>7</td>
</tr>
<tr>
<td>7</td>
<td>6</td>
</tr>
<tr>
<td>5</td>
<td>5</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>0</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>The <a href="/autoneuro/operators.html#BinnedScalingOp"><code>BinnedScalingOp</code></a> can be used to deal with these conditions.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="BinnedScalingOp" class="doc_header"><code>class</code> <code>BinnedScalingOp</code><a href="https://github.com/judowill/autoneuro/tree/main/autoneuro/operators.py#L286" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>BinnedScalingOp</code>(<strong><code>bins</code></strong>, <strong><code>measure_col</code></strong>, <strong><code>out_field</code></strong>=<em><code>None</code></em>) :: <a href="/autoneuro/operators.html#AbstractOperation"><code>AbstractOperation</code></a></p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">bins</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;min&#39;</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span> <span class="s1">&#39;scaled&#39;</span><span class="p">:</span> <span class="mi">14</span><span class="p">},</span>
        <span class="p">{</span><span class="s1">&#39;min&#39;</span><span class="p">:</span> <span class="mi">11</span><span class="p">,</span> <span class="s1">&#39;scaled&#39;</span><span class="p">:</span> <span class="mi">11</span><span class="p">},</span>
        <span class="p">{</span><span class="s1">&#39;min&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;scaled&#39;</span><span class="p">:</span> <span class="mi">9</span><span class="p">},</span>
        <span class="p">{</span><span class="s1">&#39;min&#39;</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span> <span class="s1">&#39;scaled&#39;</span><span class="p">:</span>  <span class="mi">8</span><span class="p">},</span>
        <span class="p">{</span><span class="s1">&#39;min&#39;</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="s1">&#39;scaled&#39;</span><span class="p">:</span> <span class="mi">7</span><span class="p">},</span>
        <span class="p">{</span><span class="s1">&#39;min&#39;</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span> <span class="s1">&#39;scaled&#39;</span><span class="p">:</span> <span class="mi">6</span><span class="p">},</span>
        <span class="p">{</span><span class="s1">&#39;min&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;scaled&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">},</span>
        <span class="p">{</span><span class="s1">&#39;min&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;scaled&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">},</span>
        <span class="p">{</span><span class="s1">&#39;min&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;scaled&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
        <span class="p">{</span><span class="s1">&#39;min&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;scaled&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}]</span>

<span class="n">scale_op</span> <span class="o">=</span> <span class="n">BinnedScalingOp</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="s1">&#39;delay&#39;</span><span class="p">)</span>
<span class="n">delay_scaled</span> <span class="o">=</span> <span class="n">scale_op</span><span class="o">.</span><span class="n">process_single</span><span class="p">(</span><span class="n">DATA</span><span class="p">)</span>

<span class="k">assert</span> <span class="n">delay_scaled</span> <span class="o">==</span> <span class="mi">7</span>
<span class="nb">print</span><span class="p">(</span><span class="n">scale_op</span><span class="o">.</span><span class="n">explain</span><span class="p">(</span><span class="n">DATA</span><span class="p">))</span>

<span class="n">DATA</span><span class="p">[</span><span class="s1">&#39;delay_scaled&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">delay_scaled</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>delay matched 8, scaled to 7
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now that we have the scaled value we need to handle the demographic variables.
For the <code>norman</code> set Male gender is set to 1 with females as 0.
The race also needs to be converted with white = 0 and AA = 1.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="CategoricalOp" class="doc_header"><code>class</code> <code>CategoricalOp</code><a href="https://github.com/judowill/autoneuro/tree/main/autoneuro/operators.py#L355" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>CategoricalOp</code>(<strong><code>measure_col</code></strong>, <strong><code>mapping</code></strong>, <strong><code>out_col</code></strong>) :: <a href="/autoneuro/operators.html#AbstractOperation"><code>AbstractOperation</code></a></p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">cat_op</span> <span class="o">=</span> <span class="n">CategoricalOp</span><span class="p">(</span><span class="s1">&#39;gender&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;male&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;female&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="s1">&#39;norman_gender&#39;</span><span class="p">)</span>
<span class="n">DATA</span><span class="p">[</span><span class="s1">&#39;gender&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;male&#39;</span>

<span class="n">norman_gender</span> <span class="o">=</span> <span class="n">cat_op</span><span class="o">.</span><span class="n">process_single</span><span class="p">(</span><span class="n">DATA</span><span class="p">)</span>

<span class="k">assert</span> <span class="n">norman_gender</span> <span class="o">==</span> <span class="mi">0</span>
<span class="nb">print</span><span class="p">(</span><span class="n">cat_op</span><span class="o">.</span><span class="n">explain</span><span class="p">(</span><span class="n">DATA</span><span class="p">))</span>
<span class="n">DATA</span><span class="p">[</span><span class="s1">&#39;norman_gender&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">norman_gender</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>gender:male -&gt; norman_gender:0
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now for the big finale, regression based norms.
After scaling the relevant data and handling categorical variables we need to apply an equation.
However, the equation changes depending on the individual's demographic variables.
One for african americans, one for caucasians, and a different one for spanish speakers.
The <a href="/autoneuro/operators.html#EquationFilterOp"><code>EquationFilterOp</code></a> takes care of these intricacies.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="EquationFilterOp" class="doc_header"><code>class</code> <code>EquationFilterOp</code><a href="https://github.com/judowill/autoneuro/tree/main/autoneuro/operators.py#L407" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>EquationFilterOp</code>(<strong><code>fields</code></strong>, <strong><code>regressions</code></strong>, <strong><code>out_field</code></strong>, <strong><code>result_type</code></strong>=<em><code>'zscale'</code></em>) :: <a href="/autoneuro/operators.html#AbstractOperation"><code>AbstractOperation</code></a></p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>These are best explained through their yaml imports.
Examine the <code>data/norms/norman/norman_bvmt_regnorm.yaml</code> for a complete example.</p>

</div>
</div>
</div>
</div>
 

