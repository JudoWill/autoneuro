---

title: Operators


keywords: fastai
sidebar: home_sidebar



nb_path: "01_operators.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: 01_operators.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Again, we'll uss the BVMT test as the example.
But we're going to back up a step. Since there are a bunch of different intermediate values, I want to calculate those using operations.</p>
<p>Measured Values:</p>
<ul>
<li><code>trial1</code> - Trial 1 successes</li>
<li><code>trial2</code> - Trial 2 successes</li>
<li><code>trial3</code> - Trial 3 successes</li>
<li><code>delay</code> - Delayed Successes</li>
<li><code>hits</code> - Successful recognitions with distractors</li>
<li><code>false_pos</code> - False-positive recognitions</li>
</ul>
<p>Our goal is to define all of the operations required to calculated intermediate values (ie immediate)
as well as scaled values.</p>
<p>There are three derived values to calculate:</p>
<ul>
<li><code>immediate</code>: the sum of the three trials</li>
<li><code>regonition</code>: the number of hits - false-positive recognitions</li>
<li><code>retention</code>: ratio of delayed successes and largest of the trial 2 &amp; trial 3 successes</li>
</ul>
<p>The first two can be solved with basic equations.
The third will require an additional strategy effort.</p>
<h2 id="Basic-Equations">Basic Equations<a class="anchor-link" href="#Basic-Equations"> </a></h2>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="EquationOp" class="doc_header"><code>class</code> <code>EquationOp</code><a href="https://github.com/judowill/autoneuro/tree/main/autoneuro/operators.py#L84" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>EquationOp</code>(<strong><code>out_field</code></strong>, <strong><code>equation</code></strong>, <strong><code>fields</code></strong>) :: <a href="/autoneuro/operators.html#AbstractOperation"><code>AbstractOperation</code></a></p>
</blockquote>
<p>Manipulate values with 1numexpr1 equations.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Let's imagine a individual to test.</p>
<p>Measured Values:</p>
<ul>
<li><code>trial1</code> - 5</li>
<li><code>trial2</code> - 6</li>
<li><code>trial3</code> - 7</li>
<li><code>delay</code> - 8</li>
<li><code>hits</code> - 6</li>
<li><code>false_pos</code> - 2</li>
<li><code>copy</code> - 12</li>
</ul>
<p>Using the <a href="/autoneuro/operators.html#EquationOp"><code>EquationOp</code></a> let's calculate <code>immediate</code> and <code>recognition</code>.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">DATA</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;bvmt_trial1&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;bvmt_trial2&#39;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="s1">&#39;bvmt_trial3&#39;</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span>
        <span class="s1">&#39;bvmt_delay&#39;</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="s1">&#39;bvmt_hits&#39;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="s1">&#39;bvmt_false_pos&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
        <span class="s1">&#39;bvmt_copy&#39;</span><span class="p">:</span> <span class="mi">12</span><span class="p">}</span>

<span class="n">total_op</span> <span class="o">=</span> <span class="n">EquationOp</span><span class="p">(</span><span class="s1">&#39;bvmt_immediate&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;bvmt_trial1+bvmt_trial2+bvmt_trial3&#39;</span><span class="p">,</span>
                      <span class="p">[</span><span class="s1">&#39;bvmt_trial1&#39;</span><span class="p">,</span> <span class="s1">&#39;bvmt_trial2&#39;</span><span class="p">,</span> <span class="s1">&#39;bvmt_trial3&#39;</span><span class="p">])</span>
<span class="n">immed</span> <span class="o">=</span> <span class="n">total_op</span><span class="o">.</span><span class="n">process_single</span><span class="p">(</span><span class="n">DATA</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">immed</span> <span class="o">==</span> <span class="mi">18</span>
<span class="n">DATA</span><span class="p">[</span><span class="s1">&#39;bvmt_immediate&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">immed</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stderr output_text">
<pre>&lt;ipython-input-5-f7bfcf615f94&gt;:86: FutureWarning: The `truediv` parameter in pd.eval is deprecated and will be removed in a future version.
  res = pd.eval(self.equation, local_dict=data.to_dict(), truediv=True)
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We can also <code>explain</code> the result using the method.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">total_op</span><span class="o">.</span><span class="n">explain</span><span class="p">(</span><span class="n">DATA</span><span class="p">))</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Used Equation: bvmt_trial1+bvmt_trial2+bvmt_trial3 = 18 = bvmt_immediate
</pre>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stderr output_text">
<pre>&lt;ipython-input-5-f7bfcf615f94&gt;:86: FutureWarning: The `truediv` parameter in pd.eval is deprecated and will be removed in a future version.
  res = pd.eval(self.equation, local_dict=data.to_dict(), truediv=True)
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>It can also inherently create its own data-dictionary field mapping row.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">total_op</span><span class="o">.</span><span class="n">to_field_mapping</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>internal_field                         bvmt_immediate
calculation       bvmt_trial1+bvmt_trial2+bvmt_trial3
origin                          autoneuro_calculation
section                                          None
dtype: object</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>While one might construct these operations in Python code, I actually expect most things to be saved as yaml.
So, we need a way to represent this info in that format.
This is also useful when constructing larger sets.</p>
<p>Here's the yaml example for the recognition calculation.</p>

<pre><code>type: equation
equation: "hits-false_pos"
fields: ['hits', 'false_pos']
out_field: 'recognition'</code></pre>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">yaml</span>

<span class="n">st</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">type: equation</span>
<span class="s2">equation: &quot;bvmt_hits-bvmt_false_pos&quot;</span>
<span class="s2">fields: [&#39;bvmt_hits&#39;, &#39;bvmt_false_pos&#39;]</span>
<span class="s2">out_field: &#39;bvmt_recognition&#39;</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">ret_op</span> <span class="o">=</span> <span class="n">EquationOp</span><span class="o">.</span><span class="n">from_config</span><span class="p">(</span><span class="n">yaml</span><span class="o">.</span><span class="n">full_load</span><span class="p">(</span><span class="n">st</span><span class="p">))</span>
<span class="n">recog</span> <span class="o">=</span> <span class="n">ret_op</span><span class="o">.</span><span class="n">process_single</span><span class="p">(</span><span class="n">DATA</span><span class="p">)</span>

<span class="k">assert</span> <span class="n">recog</span> <span class="o">==</span> <span class="mi">4</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ret_op</span><span class="o">.</span><span class="n">explain</span><span class="p">(</span><span class="n">DATA</span><span class="p">))</span>
<span class="n">DATA</span><span class="p">[</span><span class="s1">&#39;bvmt_recognition&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">recog</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Used Equation: bvmt_hits-bvmt_false_pos = 4 = bvmt_recognition
</pre>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stderr output_text">
<pre>&lt;ipython-input-5-f7bfcf615f94&gt;:86: FutureWarning: The `truediv` parameter in pd.eval is deprecated and will be removed in a future version.
  res = pd.eval(self.equation, local_dict=data.to_dict(), truediv=True)
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Aggregation-Operations">Aggregation Operations<a class="anchor-link" href="#Aggregation-Operations"> </a></h2><p>Due to limitations in numexpr, it cannot choose the largest of two numbers, as needed for retention.
So, we use an <a href="/autoneuro/operators.html#AggregationOp"><code>AggregationOp</code></a>.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="AggregationOp" class="doc_header"><code>class</code> <code>AggregationOp</code><a href="https://github.com/judowill/autoneuro/tree/main/autoneuro/operators.py#L175" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>AggregationOp</code>(<strong><code>out_field</code></strong>, <strong><code>aggregation</code></strong>, <strong><code>fields</code></strong>) :: <a href="/autoneuro/operators.html#AbstractOperation"><code>AbstractOperation</code></a></p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">ret_denom_op</span> <span class="o">=</span> <span class="n">AggregationOp</span><span class="p">(</span><span class="s1">&#39;bvmt_retention_denom&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;bvmt_trial2&#39;</span><span class="p">,</span> <span class="s1">&#39;bvmt_trial3&#39;</span><span class="p">])</span>
<span class="n">re_denom</span> <span class="o">=</span> <span class="n">ret_denom_op</span><span class="o">.</span><span class="n">process_single</span><span class="p">(</span><span class="n">DATA</span><span class="p">)</span>

<span class="k">assert</span> <span class="n">re_denom</span> <span class="o">==</span> <span class="mi">7</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ret_denom_op</span><span class="o">.</span><span class="n">explain</span><span class="p">(</span><span class="n">DATA</span><span class="p">))</span>
<span class="n">DATA</span><span class="p">[</span><span class="s1">&#39;bvmt_retention_denom&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">re_denom</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Aggregation: max [bvmt_trial2, bvmt_trial3]  = 7
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now that we have the denominator we can do another equation to calculate recognition.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">retent_op</span> <span class="o">=</span> <span class="n">EquationOp</span><span class="p">(</span><span class="s1">&#39;bvmt_retention&#39;</span><span class="p">,</span> <span class="s1">&#39;bvmt_delay/bvmt_retention_denom&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;bvmt_delay&#39;</span><span class="p">,</span> <span class="s1">&#39;bvmt_retention_denom&#39;</span><span class="p">])</span>
<span class="n">retent</span> <span class="o">=</span> <span class="n">retent_op</span><span class="o">.</span><span class="n">process_single</span><span class="p">(</span><span class="n">DATA</span><span class="p">)</span>

<span class="k">assert</span> <span class="n">retent</span> <span class="o">==</span> <span class="mi">8</span><span class="o">/</span><span class="mi">7</span>
<span class="nb">print</span><span class="p">(</span><span class="n">retent_op</span><span class="o">.</span><span class="n">explain</span><span class="p">(</span><span class="n">DATA</span><span class="p">))</span>
<span class="n">DATA</span><span class="p">[</span><span class="s1">&#39;bvmt_retention&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">retent</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Used Equation: bvmt_delay/bvmt_retention_denom = 1.1428571428571428 = bvmt_retention
</pre>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stderr output_text">
<pre>&lt;ipython-input-5-f7bfcf615f94&gt;:86: FutureWarning: The `truediv` parameter in pd.eval is deprecated and will be removed in a future version.
  res = pd.eval(self.equation, local_dict=data.to_dict(), truediv=True)
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Dang, the value was above 100%. And sometimes it may be negative.
By convention we clip these to a [0,1] scale, which we'll need an operation for that.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="ClipOp" class="doc_header"><code>class</code> <code>ClipOp</code><a href="https://github.com/judowill/autoneuro/tree/main/autoneuro/operators.py#L235" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>ClipOp</code>(<strong><code>field</code></strong>, <strong><code>lower</code></strong>=<em><code>0</code></em>, <strong><code>upper</code></strong>=<em><code>1</code></em>) :: <a href="/autoneuro/operators.html#AbstractOperation"><code>AbstractOperation</code></a></p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">ret_clip_op</span> <span class="o">=</span> <span class="n">ClipOp</span><span class="p">(</span><span class="s1">&#39;bvmt_retention&#39;</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">upper</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">ret_clip</span> <span class="o">=</span> <span class="n">ret_clip_op</span><span class="o">.</span><span class="n">process_single</span><span class="p">(</span><span class="n">DATA</span><span class="p">)</span>

<span class="k">assert</span> <span class="n">ret_clip</span> <span class="o">==</span> <span class="mi">1</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ret_clip_op</span><span class="o">.</span><span class="n">explain</span><span class="p">(</span><span class="n">DATA</span><span class="p">))</span>
<span class="n">DATA</span><span class="p">[</span><span class="s1">&#39;bvmt_retention&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ret_clip</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Clipped bvmt_retention to [0, 1]
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now we've calculated all of the intermediate values.
We'll need to use these values, along with demographic data, to lookup a "healthy" normal distribution.</p>
<h2 id="Normative-Lookups">Normative Lookups<a class="anchor-link" href="#Normative-Lookups"> </a></h2><p>These lookup tables are composed of lookup tables that index a mean and std given a demographic filter.
For example:</p>
<p>A 32 year old should have an <code>immediate</code> memory of 26.9 with a std of 4.6.
Our example has an <code>immediate</code> of 18, a deficit of 9, roughly 2 stds.</p>
<p>We'll need to make an object to contain the logic of matching and filtering each "element" of the table. This will be useful to deal with many different types of normative lookups.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>This <a href="/autoneuro/operators.html#MeanStdNormative"><code>MeanStdNormative</code></a> represents a table where a mean/std is provided for healthy individuals for a given filter criteria. Each element of the table is one <a href="/autoneuro/operators.html#MeanStdNormative"><code>MeanStdNormative</code></a> object and the <a href="/autoneuro/operators.html#NormativeLookupOp"><code>NormativeLookupOp</code></a> manages a list of these objects.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="MeanStdNormative" class="doc_header"><code>class</code> <code>MeanStdNormative</code><a href="https://github.com/judowill/autoneuro/tree/main/autoneuro/operators.py#L327" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>MeanStdNormative</code>(<strong><code>flt</code></strong>, <strong><code>mean</code></strong>, <strong><code>std</code></strong>) :: <a href="/autoneuro/operators.html#AbstractNormative"><code>AbstractNormative</code></a></p>
</blockquote>
<p>Deal with mean/std scaled -&gt; percentile lookup tables</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Sometimes, there is also a need for a <code>RangeNormative</code>. This is an instance where a table is formed such that a scaled score is determined from a table of max/min values.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="NormativeLookupOp" class="doc_header"><code>class</code> <code>NormativeLookupOp</code><a href="https://github.com/judowill/autoneuro/tree/main/autoneuro/operators.py#L362" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>NormativeLookupOp</code>(<strong><code>lookup_table</code></strong>, <strong><code>filter_cols</code></strong>, <strong><code>measure_col</code></strong>, <strong><code>out_name</code></strong>) :: <a href="/autoneuro/operators.html#AbstractOperation"><code>AbstractOperation</code></a></p>
</blockquote>
<p>Lookup table with normalized scores.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="LookupNormative" class="doc_header"><code>class</code> <code>LookupNormative</code><a href="https://github.com/judowill/autoneuro/tree/main/autoneuro/operators.py#L427" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>LookupNormative</code>(<strong><code>flt</code></strong>, <strong><code>mapping</code></strong>, <strong><code>post</code></strong>=<em><code>None</code></em>) :: <a href="/autoneuro/operators.html#AbstractNormative"><code>AbstractNormative</code></a></p>
</blockquote>
<p>Deal with scaled -&gt; percentile lookup tables</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>While it is possible to create these in Python, it's much easier to build using yaml definitions.</p>

<pre><code>type: normative_lookup
measure_col: immediate
filter_cols: ['age']
out_name: 'heaton_immediate'
table:
  - filter: (18 &lt;= age) &amp; (age &lt;= 21)
    mean: 28.74
    std: 4.32
  - filter: (20 &lt;= age) &amp; (age &lt;= 23)
    mean: 28.44
    std: 4.38
  ...</code></pre>
<p>The filters are anything acceptable to <code>pd.eval</code>.
The Heaton norms for the BVMT are currently in <code>data/norms/from_kate/heaton_bvmt.yaml</code></p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">DATA</span><span class="p">[</span><span class="s1">&#39;age&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">32</span>
<span class="n">bvmt_config</span> <span class="o">=</span> <span class="n">yaml</span><span class="o">.</span><span class="n">full_load</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s1">&#39;data/norms/from_kate/heaton_bvmt.yaml&#39;</span><span class="p">))</span>

<span class="n">lookup_op</span> <span class="o">=</span> <span class="n">NormativeLookupOp</span><span class="o">.</span><span class="n">from_config</span><span class="p">(</span><span class="n">bvmt_config</span><span class="p">[</span><span class="s1">&#39;operations&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
<span class="n">lookup_score</span> <span class="o">=</span> <span class="n">lookup_op</span><span class="o">.</span><span class="n">process_single</span><span class="p">(</span><span class="n">DATA</span><span class="p">)</span>

<span class="k">assert</span> <span class="n">lookup_score</span> <span class="o">==</span> <span class="o">-</span><span class="mf">1.9224137931034488</span>
<span class="nb">print</span><span class="p">(</span><span class="n">lookup_op</span><span class="o">.</span><span class="n">explain</span><span class="p">(</span><span class="n">DATA</span><span class="p">))</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Matched: (30 &lt;= age) &amp; (age &lt;= 33)
Expected 26.92+/-4.64 but observed 18
Scaled to: z=-1.9224137931034488
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The collection of these operators can be combined into a <a href="/autoneuro/calculators.html#TestCalculator"><code>TestCalculator</code></a> which manages applying these operations sequentially.
That is discussed elsewhere.</p>
<p>These features are sufficient for any analysis that requires looking up normalizations based on demographic information.
However, for regression based norms like the <code>Norman</code> set we need a further collection of operators.</p>
<h2 id="Regression-Based-Norms">Regression Based Norms<a class="anchor-link" href="#Regression-Based-Norms"> </a></h2><p>When doing regression based normalization the first step is to <code>scale</code> the raw values based on a set of bins.
This is done to help <em>normalize</em> the raw values before entering the regression equation.</p>
<p>For example. When scaling the <code>delay</code> column, the <code>norman</code> scheme uses:</p>
<table>
<thead><tr>
<th>Raw</th>
<th>Scaled</th>
</tr>
</thead>
<tbody>
<tr>
<td>12</td>
<td>14</td>
</tr>
<tr>
<td>11</td>
<td>11</td>
</tr>
<tr>
<td>10</td>
<td>9</td>
</tr>
<tr>
<td>9</td>
<td>8</td>
</tr>
<tr>
<td>8</td>
<td>7</td>
</tr>
<tr>
<td>7</td>
<td>6</td>
</tr>
<tr>
<td>5</td>
<td>5</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>0</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>The <a href="/autoneuro/operators.html#BinnedScalingOp"><code>BinnedScalingOp</code></a> can be used to deal with these conditions.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="BinnedScalingOp" class="doc_header"><code>class</code> <code>BinnedScalingOp</code><a href="https://github.com/judowill/autoneuro/tree/main/autoneuro/operators.py#L487" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>BinnedScalingOp</code>(<strong><code>bins</code></strong>, <strong><code>measure_col</code></strong>, <strong><code>out_field</code></strong>=<em><code>None</code></em>) :: <a href="/autoneuro/operators.html#AbstractOperation"><code>AbstractOperation</code></a></p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">bins</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;min&#39;</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span> <span class="s1">&#39;scaled&#39;</span><span class="p">:</span> <span class="mi">14</span><span class="p">},</span>
        <span class="p">{</span><span class="s1">&#39;min&#39;</span><span class="p">:</span> <span class="mi">11</span><span class="p">,</span> <span class="s1">&#39;scaled&#39;</span><span class="p">:</span> <span class="mi">11</span><span class="p">},</span>
        <span class="p">{</span><span class="s1">&#39;min&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;scaled&#39;</span><span class="p">:</span> <span class="mi">9</span><span class="p">},</span>
        <span class="p">{</span><span class="s1">&#39;min&#39;</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span> <span class="s1">&#39;scaled&#39;</span><span class="p">:</span>  <span class="mi">8</span><span class="p">},</span>
        <span class="p">{</span><span class="s1">&#39;min&#39;</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="s1">&#39;scaled&#39;</span><span class="p">:</span> <span class="mi">7</span><span class="p">},</span>
        <span class="p">{</span><span class="s1">&#39;min&#39;</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span> <span class="s1">&#39;scaled&#39;</span><span class="p">:</span> <span class="mi">6</span><span class="p">},</span>
        <span class="p">{</span><span class="s1">&#39;min&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;scaled&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">},</span>
        <span class="p">{</span><span class="s1">&#39;min&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;scaled&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">},</span>
        <span class="p">{</span><span class="s1">&#39;min&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;scaled&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
        <span class="p">{</span><span class="s1">&#39;min&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;scaled&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}]</span>

<span class="n">scale_op</span> <span class="o">=</span> <span class="n">BinnedScalingOp</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="s1">&#39;bvmt_delay&#39;</span><span class="p">)</span>
<span class="n">delay_scaled</span> <span class="o">=</span> <span class="n">scale_op</span><span class="o">.</span><span class="n">process_single</span><span class="p">(</span><span class="n">DATA</span><span class="p">)</span>

<span class="k">assert</span> <span class="n">delay_scaled</span> <span class="o">==</span> <span class="mi">7</span>
<span class="nb">print</span><span class="p">(</span><span class="n">scale_op</span><span class="o">.</span><span class="n">explain</span><span class="p">(</span><span class="n">DATA</span><span class="p">))</span>

<span class="n">DATA</span><span class="p">[</span><span class="s1">&#39;bvmt_delay_scaled&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">delay_scaled</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>bvmt_delay matched 8, scaled to 7
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now that we have the scaled value we need to handle the demographic variables.
For the <code>norman</code> set Male gender is set to 1 with females as 0.
The race also needs to be converted with white = 0 and AA = 1.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="CategoricalOp" class="doc_header"><code>class</code> <code>CategoricalOp</code><a href="https://github.com/judowill/autoneuro/tree/main/autoneuro/operators.py#L567" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>CategoricalOp</code>(<strong><code>measure_col</code></strong>, <strong><code>mapping</code></strong>, <strong><code>out_col</code></strong>) :: <a href="/autoneuro/operators.html#AbstractOperation"><code>AbstractOperation</code></a></p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">cat_op</span> <span class="o">=</span> <span class="n">CategoricalOp</span><span class="p">(</span><span class="s1">&#39;gender&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;male&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;female&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="s1">&#39;norman_gender&#39;</span><span class="p">)</span>
<span class="n">DATA</span><span class="p">[</span><span class="s1">&#39;gender&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;male&#39;</span>

<span class="n">norman_gender</span> <span class="o">=</span> <span class="n">cat_op</span><span class="o">.</span><span class="n">process_single</span><span class="p">(</span><span class="n">DATA</span><span class="p">)</span>

<span class="k">assert</span> <span class="n">norman_gender</span> <span class="o">==</span> <span class="mi">0</span>
<span class="nb">print</span><span class="p">(</span><span class="n">cat_op</span><span class="o">.</span><span class="n">explain</span><span class="p">(</span><span class="n">DATA</span><span class="p">))</span>
<span class="n">DATA</span><span class="p">[</span><span class="s1">&#39;norman_gender&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">norman_gender</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>gender:male -&gt; norman_gender:0
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now for the big finale, regression based norms.
After scaling the relevant data and handling categorical variables we need to apply an equation.
However, the equation changes depending on the individual's demographic variables.
One for african americans, one for caucasians, and a different one for spanish speakers.
The <a href="/autoneuro/operators.html#EquationFilterOp"><code>EquationFilterOp</code></a> takes care of these intricacies.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="EquationFilterOp" class="doc_header"><code>class</code> <code>EquationFilterOp</code><a href="https://github.com/judowill/autoneuro/tree/main/autoneuro/operators.py#L629" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>EquationFilterOp</code>(<strong><code>fields</code></strong>, <strong><code>regressions</code></strong>, <strong><code>out_field</code></strong>, <strong><code>result_type</code></strong>=<em><code>'zscale'</code></em>) :: <a href="/autoneuro/operators.html#AbstractOperation"><code>AbstractOperation</code></a></p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>These are best explained through their yaml imports.
Examine the <code>data/norms/norman/norman_bvmt_regnorm.yaml</code> for a complete example.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Multidemensional-Lookups">Multidemensional Lookups<a class="anchor-link" href="#Multidemensional-Lookups"> </a></h1><p>Some set of Heaton Norms (Grooved Peg, trails, etc) require a multi-step lookup. The original tables look like this:</p>
<table>
<thead><tr>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>Education</th>
<th>Gender</th>
<th>Age</th>
</tr>
</thead>
<tbody>
<tr>
<td>100</td>
<td>80</td>
<td>70</td>
<td>50</td>
<td>10</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>100</td>
<td>85</td>
<td>72</td>
<td>48</td>
<td>11</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>100</td>
<td>82</td>
<td>75</td>
<td>42</td>
<td>15</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>100</td>
<td>82</td>
<td>75</td>
<td>42</td>
<td>15</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>Where the first columns refer to Scaled scores and the last columns refer to categorical features. In this case, the intent would be to get the appropriate scaled score for the test, look to the row that corresponds with the patient's Education, Gender, and Age.</p>
<p>These are actually just more cases of <a href="/autoneuro/operators.html#NormativeLookupOp"><code>NormativeLookupOp</code></a> and <a href="/autoneuro/operators.html#MeanStdNormative"><code>MeanStdNormative</code></a>. So, the approach is the same.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>A general <a href="/autoneuro/operators.html#LookupNormative"><code>LookupNormative</code></a> class takes a mapping dictionary that maps raw values to scaled values. These can then be post-processed using <code>post</code>. This can convert <em>standard scores</em> and <em>percentiles</em> to <em>z-scales</em>.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>This <a href="/autoneuro/operators.html#MultiLookupOp"><code>MultiLookupOp</code></a> is just a light wrapper around the <a href="/autoneuro/operators.html#NormativeLookupOp"><code>NormativeLookupOp</code></a> that implements some helper features to create these items from "Kate Excel Sheet" format.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="MultiLookupOp" class="doc_header"><code>class</code> <code>MultiLookupOp</code><a href="https://github.com/judowill/autoneuro/tree/main/autoneuro/operators.py#L704" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>MultiLookupOp</code>(<strong><code>lookup_table</code></strong>, <strong><code>filter_cols</code></strong>, <strong><code>measure_col</code></strong>, <strong><code>out_name</code></strong>) :: <a href="/autoneuro/operators.html#NormativeLookupOp"><code>NormativeLookupOp</code></a></p>
</blockquote>
<p>Lookup table with normalized scores.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">multi_op</span> <span class="o">=</span> <span class="n">MultiLookupOp</span><span class="o">.</span><span class="n">from_sheet_format</span><span class="p">(</span><span class="s1">&#39;data/norms/from_kate/sheets/GPD.csv&#39;</span><span class="p">,</span>
                                           <span class="n">HEATON_MAPPINGS</span><span class="p">,</span>
                                           <span class="p">[</span><span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="s1">&#39;heaton_gender&#39;</span><span class="p">,</span> <span class="s1">&#39;education&#39;</span><span class="p">],</span>
                                           <span class="s1">&#39;grooved_peg_dom_scaled&#39;</span><span class="p">,</span>
                                           <span class="s1">&#39;grooved_peg_dom_heaton&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">multi_op</span><span class="o">.</span><span class="n">explain</span><span class="p">({</span><span class="s1">&#39;age&#39;</span><span class="p">:</span> <span class="mi">45</span><span class="p">,</span> <span class="s1">&#39;heaton_gender&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;education&#39;</span><span class="p">:</span> <span class="mi">13</span><span class="p">,</span>
                        <span class="s1">&#39;grooved_peg_dom_scaled&#39;</span><span class="p">:</span> <span class="mi">11</span><span class="p">}))</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Matched: ((45 &lt;= age) &amp; (age &lt; 50)) &amp; ((12 &lt; education) &amp; (education &lt;= 13)) &amp; (heaton_gender == 1)
Mapped to: 57
Scaled to: z=0.7
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Sometimes we have these files in a reversed format in which one looks for the observed value in the table and the scaled value is in the index.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="ReverseLookupOp" class="doc_header"><code>class</code> <code>ReverseLookupOp</code><a href="https://github.com/judowill/autoneuro/tree/main/autoneuro/operators.py#L770" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>ReverseLookupOp</code>(<strong><code>lookup_table</code></strong>, <strong><code>filter_cols</code></strong>, <strong><code>measure_col</code></strong>, <strong><code>out_name</code></strong>) :: <a href="/autoneuro/operators.html#MultiLookupOp"><code>MultiLookupOp</code></a></p>
</blockquote>
<p>Lookup table with normalized scores.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">path</span> <span class="o">=</span> <span class="s1">&#39;data/norms/from_kate/sheets/DSF.csv&#39;</span>
<span class="n">rlookup</span> <span class="o">=</span> <span class="n">ReverseLookupOp</span><span class="o">.</span><span class="n">from_sheet_format</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;digit_symbol_forward&#39;</span><span class="p">,</span> <span class="s1">&#39;dsf_z&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">rlookup</span><span class="o">.</span><span class="n">explain</span><span class="p">({</span><span class="s1">&#39;age&#39;</span><span class="p">:</span> <span class="mi">83</span><span class="p">,</span> <span class="s1">&#39;digit_symbol_forward&#39;</span><span class="p">:</span> <span class="mi">12</span><span class="p">}))</span>        
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Matched: (80 &lt;= age) &amp; (age &lt; 85)
Mapped to: 14.0
Scaled to: z=1.3333333333333333
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

</div>
 

